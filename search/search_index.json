{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-mvi","title":"What is MVI","text":"<p>MVI stands for Model-View-Intent. It is an architectural pattern that utilizes unidirectional data flow. The data circulates between <code>Model</code> and <code>View</code> only in one direction - from <code>Model</code> to <code>View</code> and from <code>View</code> to <code>Model</code>.</p> <p></p>"},{"location":"#what-is-mvikotlin","title":"What is MVIKotlin","text":"<p>MVIKotlin is a Kotlin Multiplatform framework that provides a way of (not only) writing shared code using MVI pattern. It also includes powerful debug tools like logging and time travel.</p>"},{"location":"#responsibility","title":"Responsibility","text":"<p>MVIKotlin does not bring or enforce any particular architecture. Its responsibility can be described as follows:</p> <ul> <li>To provide a single source of truth for <code>State</code> (the scope is not defined, it can be a whole app, a screen, a feature, or a part of a feature);</li> <li>To provide an abstraction for UI with efficient updates (however this is not obligatory, you can use whatever you want);</li> <li>To provide lifecycle-aware connections (binding) between inputs and outputs (again this is not obligatory in any way).</li> </ul> <p>Everything else is out of scope of the library, there are no definitions for \"screens\", \"features\", \"modules\", etc. Also, no particular reactive framework is enforced/exposed. This gives a lot of flexibility:</p> <ul> <li>MVIKotlin can be introduced incrementally (e.g. you can start using it in a small feature and then expand gradually);</li> <li>You can use/experiment with different architectures, approaches and/or libraries for navigation, UI, modularization, etc;</li> <li>Use whatever reactive framework you like or don't use it at all.</li> </ul> <p>You can find one of the architecture options in the samples. Again, this is just an example of one possible solution.</p>"},{"location":"#core-components","title":"Core components","text":"<p>There are two core components in MVIKotlin:</p> <ul> <li><code>Store</code> - represents <code>Model</code> from MVI, this is the place for business logic</li> <li><code>MviView</code> - represents <code>View</code> from MVI, the UI part, optional</li> </ul>"},{"location":"#how-the-data-flows","title":"How the data flows","text":"<p>Please take a look at the following diagram:</p> <p></p> <p>The <code>Store</code> produces a stream of <code>States</code> which is transformed to a stream of <code>View Models</code> by a <code>Mapper</code> function (f). The <code>View</code> renders <code>View Models</code> and produces a stream of <code>View Events</code> which is transformed to a stream of <code>Intents</code> by another <code>Mapper</code> function (f). This makes the <code>Store</code> and the <code>View</code> independent from each other. You can also combine multiple <code>States</code> (multiple <code>Stores</code>) into a single <code>View Model</code> (single <code>View</code>), or multiple <code>View Events</code> (multiple <code>Views</code>) into a single <code>Intent</code> (single <code>Store</code>). But if you have only one <code>Store</code> and only one <code>View</code> and you need simplicity then your <code>View</code> can directly render <code>States</code> and produce <code>Intents</code>.</p> <p>The <code>View</code> is subscribed to the stream of <code>View Models</code> and the <code>Store</code> is subscribed to the stream of <code>Intents</code> by a <code>Binder</code>. The <code>Binder</code> accepts <code>start</code> and <code>stop</code> signals and manages the subscriptions. The <code>Binder</code> is optional, you can subscribe components as you like.</p> <p>The <code>Store</code> also produces a stream of <code>Labels</code> - one time events. They can be transformed to <code>Intents</code> and redirected to another <code>Stores</code>. Or you can use them for routing or to display errors or for any other actions that are not so important to be part of the <code>State</code>.</p> <p>The data flows between core components only on Main thread.</p>"},{"location":"#reactivity","title":"Reactivity","text":"<p>MVI loves reactivity, it's all about data streams and transformations. MVIKotlin is a reactive framework. But the main functionality of the framework does not depend on any such library. A tiny abstraction over Rx is used instead. Extensions for Reaktive and for Coroutines libraries are provided as separate modules.</p>"},{"location":"binding_and_lifecycle/","title":"Binding","text":"<p>Connecting inputs and outputs sounds like a simple task, and indeed it is. But it can be even easier if you use Binder. It provides just two methods: <code>start()</code> and <code>stop()</code>. When you call <code>start()</code> it connects (subscribes) outputs with inputs. And when you call <code>stop()</code> it disconnects (unsubscribes).</p>"},{"location":"binding_and_lifecycle/#creating-a-binder","title":"Creating a Binder","text":"<p>Let's bind our <code>CalculatorStore</code> with <code>CalculatorView</code> which we created earlier.</p> <p>First of all we will need to map <code>CalculatorStore.State</code> to <code>CalculatorView.Model</code>:</p> <pre><code>internal val stateToModel: CalculatorStore.State.() -&gt; CalculatorView.Model =\n    {\n        CalculatorView.Model(\n            value = value.toString()\n        )\n    }\n</code></pre> <p>We also need to map <code>CalculatorView.Event</code> to <code>CalculatorStore.Intent</code>:</p> <pre><code>internal val eventToIntent: CalculatorView.Event.() -&gt; CalculatorStore.Intent =\n    {\n        when (this) {\n            is CalculatorView.Event.IncrementClicked -&gt; CalculatorStore.Intent.Increment\n            is CalculatorView.Event.DecrementClicked -&gt; CalculatorStore.Intent.Decrement\n        }\n    }\n</code></pre> <p>As mentioned earlier you can avoid separate <code>View Models</code> and <code>View Events</code> and just render <code>State</code> and/or produce <code>Intents</code>. In this case you will not need mappers, but you might get extra logic in your <code>Views</code>. In addition your <code>Stores</code> and <code>Views</code> will become coupled.</p> <p>You can bind outputs with inputs using DSL provided by <code>mvikotlin-extensions-coroutines</code> and <code>mvikotlin-extensions-reaktive</code> modules:</p> <pre><code>class CalculatorController {\n    private val store = CalculatorStoreFactory(DefaultStoreFactory).create()\n    private var binder: Binder? = null\n\n    fun onViewCreated(view: CalculatorView) {\n        binder = bind {\n            store.states.map(stateToModel) bindTo view\n            // Use store.labels to bind Labels to a consumer\n            view.events.map(eventToIntent) bindTo store\n        }\n    }\n\n    fun onStart() {\n        binder?.start()\n    }\n\n    fun onStop() {\n        binder?.stop()\n    }\n\n    fun onViewDestroyed() {\n        binder = null\n    }\n\n    fun onDestroy() {\n        store.dispose()\n    }\n}\n</code></pre> <p>The controller is supposed to be used by platforms. We are creating the <code>Binder</code> in <code>onViewCreated(CalculatorView)</code> callback which is called by a platform when the <code>CalculatorView</code> is created. The <code>Binder</code> will bind <code>CalculatorStore</code> with <code>CalculatorView</code> in <code>onStart()</code> and will unbind them in <code>onStop()</code>.</p> <p>Same way you can bind any outputs with any inputs. E.g. you can bind <code>Labels</code> of a <code>StoreA</code> with <code>Intents</code> of a <code>StoreB</code>, or <code>View Events</code> with an analytics tracker.</p> <p>Please note that you must dispose <code>Stores</code> at the end of life cycle. In this example the <code>CalculatorStore</code> is disposed in <code>onDestroy</code> callback.</p>"},{"location":"binding_and_lifecycle/#lifecycle","title":"Lifecycle","text":"<p>MVIKotlin uses Essenty library (from the same author), which provides <code>Lifecycle</code> -  a multiplatform abstraction for lifecycle states and events. The Essenty's <code>lifecycle</code> module is used as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>Lifecycle</code>.</p> <p></p>"},{"location":"binding_and_lifecycle/#binder-lifecycle","title":"Binder + Lifecycle","text":"<p>Work with the <code>Binder</code> can be simplified if you use the <code>Lifecycle</code>. You need to add one of the extension modules in order to use <code>Binder</code> with <code>Lifecycle</code>, either <code>mvikotlin-extensions-reaktive</code> or <code>mvikotlin-extensions-coroutines</code>.</p> <p>Let's simplify our previous binding example::</p> <pre><code>class CalculatorController(lifecycle: Lifecycle) {\n    private val store = CalculatorStoreFactory(DefaultStoreFactory).create()\n\n    init {\n        lifecycle.doOnDestroy(store::dispose)\n    }\n\n    fun onViewCreated(view: CalculatorView, viewLifecycle: Lifecycle) {\n        bind(viewLifecycle, BinderLifecycleMode.START_STOP) {\n            store.states.map(stateToModel) bindTo view\n            // Use store.labels to bind Labels to a consumer\n            view.events.map(eventToIntent) bindTo store\n        }\n    }\n}\n</code></pre> <p>We passed the <code>viewLifecycle</code> together with the <code>CalculatorView</code> itself and used it for binding. Now <code>Binder</code> will automatically connect endpoints when started and disconnect when stopped.</p> <p>Same as before we dispose the <code>CalculatorStore</code> at the end of <code>CalculatorController</code> life cycle.</p> <p>Please refer to the samples for more examples.</p>"},{"location":"logging/","title":"Logging","text":"<p>Logging is an essential tool for almost every app. MVIKotlin provides logging functionality via the LoggingStoreFactory wrapper located in the <code>mvikotlin-logging</code> module. It is possible to replace the default <code>Logger</code> and <code>LogFormatter</code> with a custom ones.</p> <p>\u26a0\ufe0f Logging is a debugging tool and may affect performance, ideally it should not be used in production.</p>"},{"location":"logging/#using-loggingstorefactory","title":"Using LoggingStoreFactory","text":"<p>Suppose we have the following <code>Store</code> factory:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            // ...\n        ) {\n        }\n\n    // ...\n}\n</code></pre> <p>It accepts a <code>StoreFactory</code> and uses it to create an implementation of the <code>CalculatorStore</code>. You can now pass any <code>StoreFactory</code> here. So if you want to add logging just pass an instance of the <code>LoggingStoreFactory</code>:</p> <pre><code>val storeFactory = LoggingStoreFactory(DefaultStoreFactory)\n\nCalculatorStoreFactory(storeFactory).create()\n</code></pre> <p>Normally you should define a global <code>StoreFactory</code> somewhere in the main app and pass it down to all the dependencies.</p> <p>Please refer to the samples for more examples.</p>"},{"location":"state_preservation/","title":"State preservation","text":"<p>Sometimes it might be necessary to preserve a state (e.g. a state of a <code>Store</code>) in order to restore it later. A very common use case is Android Activity recreation due to configuration changes, or process death. If you are working on a pure Android project (not multiplatform) then AndroidX SavedStateRegistry can be used directly. For multiplatform projects you can use the <code>StateKeeper</code> from Essenty library (from the same author). Please familiarise yourself with Essenty library, especially with the <code>StateKeeper</code>.</p>"},{"location":"state_preservation/#retaining-objects","title":"Retaining objects","text":"<p>Another use case is to retain an object instance over its scope recreation. This is also commonly used in Android when configuration changes occur. If you are working on a pure Android project (not multiplatform) then AndroidX ViewModelStore and ViewModelProvider can be used directly. For multiplatform projects you can use <code>InstanceKeeper</code> from Essenty library (from the same author). Please familiarise yourself with Essenty library, especially with the <code>InstanceKeeper</code>.</p>"},{"location":"state_preservation/#examples","title":"Examples","text":""},{"location":"state_preservation/#preserving-state-of-a-store","title":"Preserving state of a Store","text":"<pre><code>internal interface CalculatorStore : Store&lt;Intent, State, Nothing&gt; {\n    @Parcelize\n    data class State(\n        val isLoading: Boolean = false,\n        // Other properties\n    ) : Parcelable\n\n    // Omitted code\n}\n\ninternal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(stateKeeper: StateKeeper): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            initialState = stateKeeper.consume(key = \"CalculatorStoreState\") ?: State(),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {\n        }.also {\n            stateKeeper.register(key = \"CalculatorStoreState\") {\n                it.state.copy(isLoading = false) // We can reset any transient state here\n            }\n        }\n\n    // Omitted code\n}\n</code></pre>"},{"location":"state_preservation/#retaining-a-whole-store","title":"Retaining a whole Store","text":"<pre><code>import com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass CalculatorController(instanceKeeper: InstanceKeeper) {\n\n    private val store: CalculatorStore =\n        instanceKeeper.getStore(::calculatorStore)\n\n    /*\n     * Create a new instance of CalculatorStore.\n     * \u26a0\ufe0f Pay attention to not leak any dependencies.\n     */\n    private fun calculatorStore(): CalculatorStore = // Create the Store\n}\n</code></pre>"},{"location":"state_preservation/#retaining-an-arbitrary-object","title":"Retaining an arbitrary object","text":"<pre><code>import com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\n\nclass CalculatorController(instanceKeeper: InstanceKeeper) {\n\n    private val something: Something =\n        instanceKeeper.getOrCreate(::Something)\n\n    /*\n     * Instances of this class will be retained.\n     * \u26a0\ufe0f Pay attention to not leak any dependencies.\n     */\n    private class Something : InstanceKeeper.Instance {\n        override fun onDestroy() {\n            // Clean-up any resources here\n        }\n    }\n}\n</code></pre>"},{"location":"state_preservation/#creating-statekeeper-in-android","title":"Creating StateKeeper in Android","text":"<pre><code>import com.arkivanov.essenty.statekeeper.stateKeeper\n\nclass MainActivity : AppCompatActivity() { // Same for AndroidX Fragment\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val stateKeeper = stateKeeper()\n        // Pass the StateKeeper to dependencies\n    }\n}\n</code></pre>"},{"location":"state_preservation/#creating-instancekeeper-in-android","title":"Creating InstanceKeeper in Android","text":"<pre><code>import com.arkivanov.essenty.instancekeeper.instanceKeeper\n\nclass MainActivity : AppCompatActivity() { // Same for AndroidX Fragment\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val instanceKeeper = instanceKeeper()\n        // Pass the InstanceKeeper to dependencies\n    }\n}\n</code></pre>"},{"location":"store/","title":"Store","text":"<p><code>Store</code> is the place for business logic. In MVIKotlin it is represented by the <code>Store</code> interface which is located in the <code>mvikotlin</code> module. You can check its definition here.</p> <p>It has the following features:</p> <ul> <li>There are three generic parameters: input <code>Intent</code> and output <code>State</code> and <code>Label</code>.</li> <li>The property named <code>state</code> returns the current <code>State</code> of the <code>Store</code>.</li> <li>Can be instantiated (created) on any thread.</li> <li>Its <code>states(Observer&lt;State&gt;)</code> method is used to subscribe for <code>State</code> updates. When subscribed it emits the current <code>State</code> of the <code>Store</code>. Can be called (subscribed) on any thread, <code>States</code> are emitted always on the main thread.</li> <li>The <code>labels(Observer&lt;Label&gt;)</code> method is used to subscribe for <code>Labels</code>. Can be called (subscribed) on any thread, <code>Labels</code> are emitted always on the main thread.</li> <li>The <code>accept(Intent)</code>  method supplies the <code>Store</code> with the <code>Intents</code>, must be called only on the main thread.</li> <li>The <code>init()</code> method initializes the <code>Store</code> and triggers the <code>Bootstrapper</code> if applicable, must be called only on the main thread.</li> <li>The <code>dispose()</code> method disposes the <code>Store</code> and cancels all its async operations, must be called only on the main thread.</li> </ul>"},{"location":"store/#observing-states-and-labels","title":"Observing states and labels","text":"<p>Usually you don't need to use <code>states(Observer)</code> or <code>labels(Observer)</code> methods directly. There are extensions available for <code>Reaktive</code> and <code>kotlinx.coroutines</code> libraries. However, you will need those methods if you implement custom extensions. See also - Binding and Lifecycle.</p>"},{"location":"store/#observing-with-reaktive","title":"Observing with Reaktive","text":"<p>Add the following dependency to your <code>build.gradle</code> file:</p> <pre><code>implementation(\"com.arkivanov.mvikotlin:mvikotlin-extensions-reaktive:&lt;version&gt;\")\n</code></pre> <p>Now you can observe states and labels using the following extensions:</p> <ul> <li><code>Store.states</code> - returns <code>BehaviorObservable</code> of type <code>State</code>.</li> <li><code>Store.labels</code> - returns <code>Observable</code> of type <code>Label</code>.</li> </ul>"},{"location":"store/#observing-with-kotlinxcoroutines","title":"Observing with kotlinx.coroutines","text":"<p>Add the following dependency to your <code>build.gradle</code> file:</p> <pre><code>implementation(\"com.arkivanov.mvikotlin:mvikotlin-extensions-coroutines:&lt;version&gt;\")\n</code></pre> <p>Now you can observe states and labels using the following extensions:</p> <ul> <li><code>Store.states</code> - returns <code>Flow</code> of type <code>State</code>.</li> <li><code>Store.stateFlow</code> - returns <code>StateFlow</code> of type <code>State</code>.</li> <li><code>Store.labels</code> - returns <code>Flow</code> of type <code>Label</code>.</li> </ul>"},{"location":"store/#store-structure","title":"Store structure","text":"<p>Every <code>Store</code> has up to three components: <code>Bootstrapper</code>, <code>Executor</code> and <code>Reducer</code>. Here is the diagram of how they are connected:</p> <p></p>"},{"location":"store/#bootstrapper","title":"Bootstrapper","text":"<p>This component bootstraps (kick-starts) the <code>Store</code>. If passed to the <code>StoreFactory</code> it will be called at some point during <code>Store</code> initialization. The <code>Bootstrapper</code> produces <code>Actions</code> that are processed by the <code>Executor</code>. The <code>Bootstrapper</code> is executed always on the main thread, <code>Actions</code> must be also dispatched only on the main thread. However you are free to switch threads while the <code>Bootstrapper</code> is being executed.</p> <p>\u26a0\ufe0f Please note that <code>Bootstrappers</code> are stateful and so can not be <code>object</code>s (singletons).</p>"},{"location":"store/#executor-version-4x","title":"Executor (version 4.x)","text":"<p>This is the place for business logic, all asynchronous operations also happen here. <code>Executor</code> accepts and processes <code>Intents</code> from the outside world and <code>Actions</code> from inside the <code>Store</code>. The <code>Executor</code> has three outputs: <code>Messages</code>, <code>Action</code> and <code>Labels</code>. <code>Messages</code> are passed to the <code>Reducer</code>, <code>Actions</code> are forwarded back to the <code>Executor</code> itself, <code>Labels</code> are emitted straight to the outside world. The <code>Executor</code> has constant access to the current <code>State</code> of the <code>Store</code>, a new <code>State</code> is visible for the <code>Executor</code> right after the <code>Message</code> is dispatched. The <code>Executor</code> is executed always on the main thread, <code>Messages</code> and <code>Labels</code> must be also dispatched only on the main thread. However, you are free to switch threads while processing <code>Action</code> or <code>Intents</code>.</p> <p>\u26a0\ufe0f Please note that <code>Executors</code> are stateful and so can not be <code>object</code>s (singletons).</p>"},{"location":"store/#executor-version-3x","title":"Executor (version 3.x)","text":"<p>This is the place for business logic, all asynchronous operations also happen here. <code>Executor</code> accepts and processes <code>Intents</code> from the outside world and <code>Actions</code> from the <code>Bootstrapper</code>. The <code>Executor</code> has two outputs: <code>Messages</code> and <code>Labels</code>. <code>Messages</code> are passed to the <code>Reducer</code>, <code>Labels</code> are emitted straight to the outside world. The <code>Executor</code> has constant access to the current <code>State</code> of the <code>Store</code>, a new <code>State</code> is visible for the <code>Executor</code> right after the <code>Message</code> is dispatched. The <code>Executor</code> is executed always on the main thread, <code>Messages</code> and <code>Labels</code> must be also dispatched only on the main thread. However, you are free to switch threads while processing <code>Action</code> or <code>Intents</code>.</p> <p>\u26a0\ufe0f Please note that <code>Executors</code> are stateful and so can not be <code>object</code>s (singletons).</p>"},{"location":"store/#reducer","title":"Reducer","text":"<p>This component is basically a function that accepts a <code>Message</code> from the <code>Executor</code> and the current <code>State</code> of the <code>Store</code> and returns a new <code>State</code>. The <code>Reducer</code> is called for every <code>Message</code> produced by the <code>Executor</code> and the new <code>State</code> is applied and emitted as soon as the <code>Reducer</code> call returns. The <code>Reducer</code> is always called on the main thread.</p>"},{"location":"store/#creating-a-store","title":"Creating a Store","text":"<p>Normally you don't need to implement the <code>Store</code> interface directly. Instead you should use StoreFactory which will create a <code>Store</code> for you. All you need to do is to provide up to three components (<code>Bootstrapper</code>, <code>Executor</code> and <code>Reducer</code>) and an initial <code>State</code>. <code>StoreFactory</code> is used to abstract from a <code>Store</code> implementation. We can use different factories depending on circumstances and combine them as needed.</p> <p>There are a number of factories provided by MVIKotlin: - DefaultStoreFactory creates a default implementation of <code>Store</code> and is provided by the <code>mvikotlin-main</code> module. - LoggingStoreFactory wraps another <code>StoreFactory</code> and adds logging, it's provided by the <code>mvikotlin-logging</code> module. - TimeTravelStoreFactory is provided by the <code>mvikotlin-timetravel</code> module, it creates a <code>Store</code> with time travel functionality.</p>"},{"location":"store/#initializing-a-store","title":"Initializing a Store","text":"<p>During its initialization, the <code>Store</code> establishes internal connections and calls the <code>Bootstrapper</code>. By default <code>Stores</code> are initialized automatically by the <code>StoreFactory</code>. You can opt-out from the automatic initialization by passing <code>autoInit=false</code> argument to the <code>StoreFactory.create(...)</code> function.</p> <p>\u26a0\ufe0f When automatic initialization is disabled, you should manually call the <code>Store.init()</code> method.</p>"},{"location":"store/#idea-live-templates","title":"IDEA Live Templates","text":"<p>To speed up the creation of new Stores, you can use the following IDEA Live Templates. Download the archive and use the guide to import live templates into your IDE. You may need to restart the IDE after import.</p> <p>\u26a0\ufe0f Safari browser may automatically unzip download archives, make sure that you import a zip file and not a folder.</p>"},{"location":"store/#usage","title":"Usage","text":"<p>Create a new Kotlin file and type one of the following abbreviations:</p> <ul> <li><code>mvisi</code> - adds a skeleton <code>Store</code> interface.</li> <li><code>mvisr</code> - adds a skeleton <code>Store</code> factory with Reaktive.</li> <li><code>mvisc</code> - adds a skeleton <code>Store</code> factory with coroutines.</li> <li><code>mvisfr</code> - adds skeletons for <code>Store</code> interface and factory with Reaktive.</li> <li><code>mvisfc</code> - adds skeletons for <code>Store</code> interface and factory with coroutines.</li> </ul>"},{"location":"store/#simplest-example","title":"Simplest example","text":"<p>The following examples use the default full-featured API. For a simplified DSL, please refer to the corresponding section - Store DSL API.</p> <p>Let's start from a very basic example. We will create a simple counter <code>Store</code> that will increment and decrement its value.</p> <p>The first thing we should do is to define an interface. This is how it will look:</p> <pre><code>internal interface CalculatorStore : Store&lt;Intent, State, Nothing&gt; {\n\n    sealed interface Intent {\n        object Increment : Intent\n        object Decrement : Intent\n    }\n\n    data class State(\n        val value: Long = 0L\n    )\n}\n</code></pre> <p>The <code>CalculatorStore</code> interface itself can be marked as <code>internal</code>, so it will be an implementation detail of a module. Also <code>CalculatorStore</code> has two <code>Intents</code> (<code>Increment</code> and <code>Decrement</code>) and the <code>State</code> with just a <code>Long</code> value. This is the public API of our <code>Store</code>.</p> <p>Now it's time for implementation:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            initialState = State(),\n            reducer = ReducerImpl\n        ) {\n        }\n\n    private object ReducerImpl : Reducer&lt;State, Intent&gt; {\n        override fun State.reduce(msg: Intent): State =\n            when (msg) {\n                is Intent.Increment -&gt; copy(value = value + 1L)\n                is Intent.Decrement -&gt; copy(value = value - 1L)\n            }\n    }\n}\n</code></pre> <p>The only component we need is the <code>Reducer</code>. It accepts <code>Intents</code> and modifies the <code>State</code> by incrementing or decrementing its value. The factory function <code>create()</code> uses the <code>StoreFactory</code> which is passed as a dependency.</p>"},{"location":"store/#adding-executor","title":"Adding Executor","text":"<p>Currently our <code>CalculatorStore</code> can only increment and decrement its value. But what if we need to calculate something? Let's say we want to calculate a sum of numbers from 1 to N. We will need an additional <code>Intent</code>:</p> <pre><code>internal interface CalculatorStore : Store&lt;Intent, State, Nothing&gt; {\n\n    sealed interface Intent {\n        object Increment : Intent\n        object Decrement : Intent\n        data class Sum(val n: Int): Intent // &lt;-- Add this line\n    }\n\n    data class State(\n        val value: Long = 0L\n    )\n}\n</code></pre> <p>The idea is that <code>CalculatorStore</code> will accept <code>Intent.Sum(N)</code>, calculate the sum of numbers from 1 to N and update the <code>State</code> with the result. But the calculation may take some time, so it should be performed on a background thread. For this we need the <code>Executor</code>.</p> <p>So that our <code>Executor</code> could communicate with the <code>Reducer</code> we will need <code>Messages</code>:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    private sealed interface Msg {\n        class Value(val value: Long) : Msg\n    }\n}\n</code></pre> <p>We will need a new <code>Reducer</code> because now it will accept <code>Messages</code> instead of <code>Intents</code>:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    private sealed interface Msg {\n        class Value(val value: Long) : Msg\n    }\n\n    private object ReducerImpl : Reducer&lt;State, Msg&gt; {\n        override fun State.reduce(msg: Msg): State =\n            when (msg) {\n                is Msg.Value -&gt; copy(value = msg.value)\n            }\n    }\n}\n</code></pre> <p>There is only one possible <code>Msg.Value(Long)</code> which just replaces whatever value in <code>State</code>.</p> <p>Now it's time for the <code>Executor</code>. If you are interested you can find the interface here. Luckily we don't need to implement this entire interface. Instead we can extend a base implementation.</p> <p>There are two base <code>Executors</code> provided by <code>MVIKotlin</code>:</p> <ul> <li>ReaktiveExecutor - this implementation is based on the Reaktive library and is provided by <code>mvikotlin-extensions-reaktive</code> module</li> <li>CoroutineExecutor - this implementation is based on the Coroutines library and is provided by <code>mvikotlin-extensions-coroutines</code> module</li> </ul> <p>Let's try both.</p>"},{"location":"store/#reaktiveexecutor","title":"ReaktiveExecutor","text":""},{"location":"store/#version-v40","title":"Version v4.0","text":"<pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    // ...\n\n    private class ExecutorImpl : ReaktiveExecutor&lt;Intent, Nothing, State, Msg, Nothing&gt;() {\n        override fun executeIntent(intent: Intent) =\n            when (intent) {\n                is Intent.Increment -&gt; dispatch(Msg.Value(state().value + 1))\n                is Intent.Decrement -&gt; dispatch(Msg.Value(state().value - 1))\n                is Intent.Sum -&gt; sum(intent.n)\n            }\n\n        private fun sum(n: Int) {\n            singleFromFunction { (1L..n.toLong()).sum() }\n                .subscribeOn(computationScheduler)\n                .observeOn(mainScheduler)\n                .subscribeScoped { dispatch(Msg.Value(it)) }\n        }\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"store/#version-v30","title":"Version v3.0","text":"<pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    // ...\n\n    private class ExecutorImpl : ReaktiveExecutor&lt;Intent, Nothing, State, Msg, Nothing&gt;() {\n        override fun executeIntent(intent: Intent, getState: () -&gt; State) =\n            when (intent) {\n                is Intent.Increment -&gt; dispatch(Msg.Value(getState().value + 1))\n                is Intent.Decrement -&gt; dispatch(Msg.Value(getState().value - 1))\n                is Intent.Sum -&gt; sum(intent.n)\n            }\n\n        private fun sum(n: Int) {\n            singleFromFunction { (1L..n.toLong()).sum() }\n                .subscribeOn(computationScheduler)\n                .observeOn(mainScheduler)\n                .subscribeScoped { dispatch(Msg.Value(it)) }\n        }\n    }\n\n    // ...\n}\n</code></pre> <p>So we extended the <code>ReaktiveExecutor</code> class and implemented the <code>executeIntent</code> method. This method gives us an <code>Intent</code> and a supplier of the current <code>State</code>. For <code>Intent.Increment</code> and <code>Intent.Decrement</code> we simply send the <code>Message</code> with a new value using the <code>dispatch</code> method. But for <code>Intent.Sum</code> we use <code>Reaktive</code> for multithreading. We calculate the sum on the <code>computationScheduler</code> and then switch to the <code>mainScheduler</code> and <code>dispatch</code> the <code>Message</code>.</p> <p>\u26a0\ufe0f <code>ReaktiveExecutor</code> implements Reaktive's DisposableScope which provides a bunch of additional extension functions. We used one of those functions - <code>subscribeScoped</code>. This ensures that the subscription is disposed when the <code>Store</code> (and so the <code>Executor</code>) is disposed.</p>"},{"location":"store/#coroutineexecutor","title":"CoroutineExecutor","text":""},{"location":"store/#version-v40_1","title":"Version v4.0","text":"<pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    // ...\n\n    private class ExecutorImpl : CoroutineExecutor&lt;Intent, Nothing, State, Msg, Nothing&gt;() {\n        override fun executeIntent(intent: Intent) =\n            when (intent) {\n                is Intent.Increment -&gt; dispatch(Msg.Value(state().value + 1))\n                is Intent.Decrement -&gt; dispatch(Msg.Value(state().value - 1))\n                is Intent.Sum -&gt; sum(intent.n)\n            }\n\n        private fun sum(n: Int) {\n            scope.launch {\n                val sum = withContext(Dispatchers.Default) { (1L..n.toLong()).sum() }\n                dispatch(Msg.Value(sum))\n            }\n        }\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"store/#version-v30_1","title":"Version v3.0","text":"<pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    // ...\n\n    private class ExecutorImpl : CoroutineExecutor&lt;Intent, Nothing, State, Msg, Nothing&gt;() {\n        override fun executeIntent(intent: Intent, getState: () -&gt; State) =\n            when (intent) {\n                is Intent.Increment -&gt; dispatch(Msg.Value(getState().value + 1))\n                is Intent.Decrement -&gt; dispatch(Msg.Value(getState().value - 1))\n                is Intent.Sum -&gt; sum(intent.n)\n            }\n\n        private fun sum(n: Int) {\n            scope.launch {\n                val sum = withContext(Dispatchers.Default) { (1L..n.toLong()).sum() }\n                dispatch(Msg.Value(sum))\n            }\n        }\n    }\n\n    // ...\n}\n</code></pre> <p>Here we extended the <code>CoroutineExecutor</code> class. The sum is calculated on the <code>Default</code> dispatcher and the <code>Message</code> is dispatched on the <code>Main</code> thread.</p> <p>\u26a0\ufe0f <code>CoroutineExecutor</code> provides the <code>CoroutineScope</code> property named <code>scope</code>, which can be used to run asynchronous tasks. The scope uses <code>Dispatchers.Main</code> dispatcher by default, which can be overriden by passing different <code>CoroutineContext</code> to the <code>CoroutineExecutor</code> constructor. The scope is automatically cancelled when the <code>Store</code> is disposed.</p>"},{"location":"store/#forwarding-actions","title":"Forwarding Actions","text":"<p>Starting with MVIKotlin version 4.0, it is also possible to send <code>Actions</code> from the <code>Executor</code> using <code>forward(Action)</code> method. The <code>Action</code> automatically redirected back to the <code>Executor#executeAction</code> method. This allows reusing <code>Actions</code> easier, and also proper processing by wrapping <code>Stores</code> (like logging or time-traveling).</p>"},{"location":"store/#publishing-labels","title":"Publishing Labels","text":"<p><code>Labels</code> are one-time events produced by the <code>Store</code>, or more specifically by the <code>Executor</code>. Once published (emitted) they are delivered to all current subscribers and are not cached. The <code>Executor</code> has special method for it: <code>publish(Label)</code>.</p> <p>\u26a0\ufe0f If a <code>Label</code> is published straight from <code>Executor.executeAction</code> method, the <code>Store</code> may have no subscribers yet. This may happen if the <code>Store</code> is still being created, and the initialization is still in progress. Prefer manual <code>Store</code> initialization in this case.</p>"},{"location":"store/#creating-the-store","title":"Creating the Store","text":"<p>We also need to pass a factory of our <code>Executor</code> to the <code>StoreFactory</code>:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            initialState = State(),\n            executorFactory = ::ExecutorImpl, // &lt;-- Pass Executor factory\n            reducer = ReducerImpl\n        ) {\n        }\n\n    // ...\n}\n</code></pre> <p>Why factory and not just an instance of the <code>Executor</code>? Because of the time travel feature. When debugging time travel events it creates separate instances of <code>Executors</code> when necessary and fakes their <code>States</code>.</p> <p>\u26a0\ufe0f Please note that <code>executorFactory</code> should return a new instance of the <code>Executor</code> every time it is called.</p>"},{"location":"store/#adding-bootstrapper","title":"Adding Bootstrapper","text":"<p>When we create a new instance of a <code>Store</code> it will stay in an initial <code>State</code> and do nothing until you supply an <code>Intent</code>. But sometimes we need to bootstrap (or kick start) a <code>Store</code> so it will start doing something once created. E.g. it can start listening for events from a server or load something from a database. This is why we need the <code>Bootstrapper</code>. As mentioned in the beginning the <code>Bootstrapper</code> produces <code>Actions</code> that are processed by the <code>Executor</code> the same way as <code>Intents</code>.</p> <p>Our <code>CalculatorStore</code> is able to calculate sums of numbers from 1 to N. Currently it does this when <code>Intent.Sum(N)</code> is received. Let's use the <code>Bootstrapper</code> to calculate <code>sum(100)</code> when the <code>CalculatorStore</code> is created. Our <code>Executor</code> already has everything to for sum calculation, so we can just send a triggering <code>Action</code> to the <code>Executor</code>, same as <code>Intent.Sum(N)</code>.</p> <p>Let's first add an <code>Action</code>:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    // ...\n\n    private sealed interface Action {\n        class Sum(val n: Int): Action\n    }\n\n    // ...\n}\n</code></pre> <p>Now it's time to handle the <code>Action</code> in the <code>ReaktiveExecutor</code>:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    // ...\n\n    private class ExecutorImpl : ReaktiveExecutor&lt;Intent, Action, State, Msg, Nothing&gt;() {\n        override fun executeAction(action: Action, getState: () -&gt; State) =\n            when (action) {\n                is Action.Sum -&gt; sum(action.n)\n            }\n\n        // ...\n    }\n\n    // ...\n}\n</code></pre> <p>And same for the <code>CoroutineExecutor</code>:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    // ...\n\n    private class ExecutorImpl : CoroutineExecutor&lt;Intent, Action, State, Msg, Nothing&gt;() {\n        override fun executeAction(action: Action, getState: () -&gt; State) =\n            when (action) {\n                is Action.Sum -&gt; sum(action.n)\n            }\n\n        // ...\n    }\n\n    // ...\n}\n</code></pre> <p>The only thing is missing is we need to somehow trigger the <code>Action</code>. We need to pass a <code>Bootstrapper</code> to the <code>StoreFactory</code>. For such a simple case we can use 'SimpleBootstrapper`:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            initialState = State(),\n            bootstrapper = SimpleBootstrapper(Action.Sum(100)), // &lt;-- Add this line\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {\n        }\n\n    // ...\n}\n</code></pre> <p>The <code>SimpleBootstrapper</code> just dispatches the provided <code>Actions</code>. But sometimes we need more, e.g. do some background work.</p> <p>Using <code>ReaktiveBootstrapper</code> from the <code>mvikotlin-extensions-reaktive</code> module:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            initialState = State(),\n            bootstrapper = BootstrapperImpl(), // &lt;-- Pass BootstrapperImpl to the StoreFactory\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {\n        }\n\n    private sealed interface Action {\n        class SetValue(val value: Long): Action // &lt;-- Use another Action\n    }\n\n    // ...\n\n    private class BootstrapperImpl : ReaktiveBootstrapper&lt;Action&gt;() {\n        override fun invoke() {\n            singleFromFunction { (1L..1000000.toLong()).sum() }\n                .subscribeOn(computationScheduler)\n                .observeOn(mainScheduler)\n                .subscribeScoped { dispatch(Action.SetValue(it)) }\n        }\n    }\n\n    private class ExecutorImpl : ReaktiveExecutor&lt;Intent, Action, State, Msg, Nothing&gt;() {\n        override fun executeAction(action: Action, getState: () -&gt; State) =\n            when (action) {\n                is Action.SetValue -&gt; dispatch(Msg.Value(action.value)) // &lt;-- Handle the Action\n            }\n\n        // ...\n    }\n\n    // ...\n}\n</code></pre> <p>\u26a0\ufe0f <code>ReaktiveBootstrapper</code> also implements <code>DisposableScope</code>, same as <code>ReaktiveExecutor</code>. So we can use <code>subscribeScoped</code> extension functions here as well.</p> <p>Using <code>CoroutineBootstrapper</code> from the <code>mvikotlin-extensions-coroutines</code> module:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            initialState = State(),\n            bootstrapper = BootstrapperImpl(),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {\n        }\n\n    private sealed interface Action {\n        class SetValue(val value: Long): Action\n    }\n\n    // ...\n\n    private class BootstrapperImpl : CoroutineBootstrapper&lt;Action&gt;() {\n        override fun invoke() {\n            scope.launch {\n                val sum = withContext(Dispatchers.Default) { (1L..1000000.toLong()).sum() }\n                dispatch(Action.SetValue(sum))\n            }\n        }\n    }\n\n    private class ExecutorImpl : CoroutineExecutor&lt;Intent, Action, State, Msg, Nothing&gt;() {\n        override fun executeAction(action: Action, getState: () -&gt; State) =\n            when (action) {\n                is Action.SetValue -&gt; dispatch(Msg.Value(action.value))\n            }\n\n        // ...\n    }\n\n    // ...\n}\n</code></pre> <p>\u26a0\ufe0f <code>CoroutineBootstrapper</code> also provides the <code>CoroutineScope</code> property named <code>scope</code>, same as <code>CoroutineExecutor</code>. So we can use it run asynchronous tasks.</p> <p></p>"},{"location":"store/#store-dsl-api","title":"Store DSL API","text":"<p>The approach demonstrated above is default, but may be considered verbose. MVIKotlin provides additional Store DSL API.</p>"},{"location":"store/#reaktive-way","title":"Reaktive way","text":"<pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create&lt;Intent, Action, Msg, State, Nothing&gt;(\n            name = \"CounterStore\",\n            initialState = State(),\n            bootstrapper = reaktiveBootstrapper {\n                singleFromFunction { (1L..1000000.toLong()).sum() }\n                    .subscribeOn(computationScheduler)\n                    .observeOn(mainScheduler)\n                    .subscribeScoped { // Use the DisposableScope for scoped subscriptions\n                        dispatch(Action.SetValue(it)) // Dispatch an Action\n                    }\n            },\n            executorFactory = reaktiveExecutorFactory {\n                // Register a handler for Action.SetValue\n                onAction&lt;Action.SetValue&gt; { action -&gt;\n                    dispatch(Msg.Value(action.value)) // Read the Action and dispatch a Message\n                }\n\n                // Register a handler for Intent.Increment\n                onIntent&lt;Intent.Increment&gt; {\n                    dispatch(Msg.Value(state.value + 1)) // Read the current state and dispatch a Message\n                }\n\n                onIntent&lt;Intent.Decrement&gt; { dispatch(Msg.Value(state.value - 1)) }\n\n                onIntent&lt;Intent.Sum&gt; { intent -&gt;\n                    singleFromFunction { (1L..intent.n.toLong()).sum() }\n                        .subscribeOn(computationScheduler)\n                        .observeOn(mainScheduler)\n                        .subscribeScoped { dispatch(Msg.Value(it)) } // Use the DisposableScope for scoped subscriptions\n                }\n            },\n            reducer = { msg -&gt;\n                when (msg) {\n                    is Msg.Value -&gt; copy(value = msg.value)\n                }\n            }\n        ) {\n        }\n\n    private sealed interface Action {\n        // ...\n    }\n\n    private sealed interface Msg {\n        // ...\n    }\n}\n</code></pre>"},{"location":"store/#coroutines-way","title":"Coroutines way","text":"<pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create&lt;Intent, Action, Msg, State, Nothing&gt;(\n            name = \"CounterStore\",\n            initialState = State(),\n            bootstrapper = coroutineBootstrapper {\n                launch { // Launch a coroutine\n                    val sum = withContext(Dispatchers.Default) { (1L..1000000.toLong()).sum() }\n                    dispatch(Action.SetValue(sum)) // Dispatch an Action\n                }\n            },\n            executorFactory = coroutineExecutorFactory {\n                // Register a handler for Action.SetValue\n                onAction&lt;Action.SetValue&gt; { action -&gt;\n                    dispatch(Msg.Value(action.value)) // Read the Action and dispatch a Message\n                }\n\n                // Register a handler for Intent.Increment\n                onIntent&lt;Intent.Increment&gt; {\n                    dispatch(Msg.Value(state.value + 1)) // Read the current state and dispatch a Message\n                }\n\n                onIntent&lt;Intent.Decrement&gt; { dispatch(Msg.Value(state.value - 1)) }\n\n                onIntent&lt;Intent.Sum&gt; { intent -&gt;\n                    launch { // Launch a coroutine\n                        val sum = withContext(Dispatchers.Default) { (1L..intent.n.toLong()).sum() }\n                        dispatch(Msg.Value(sum))\n                    }\n                }\n            },\n            reducer = { msg -&gt;\n                when (msg) {\n                    is Msg.Value -&gt; copy(value = msg.value)\n                }\n            }\n        ) {\n        }\n\n    private sealed interface Action {\n        // ...\n    }\n\n    private sealed interface Msg {\n        // ...\n    }\n}\n</code></pre>"},{"location":"store/#alternative-way-of-creating-a-store","title":"Alternative way of creating a Store","text":"<p>If the amount of boilerplate code is still significant, there is an alternative way of creating a <code>Store</code>. Just get rid of the dedicated <code>Store</code> interface and put its content in top level.</p> <pre><code>internal sealed interface Intent {\n    // ...\n}\n\ninternal data class State(\n    // ...\n)\n\ninternal sealed interface Label {\n    // ...\n}\n\ninternal fun CalculatorStore(storeFactory: StoreFactory): Store&lt;Intent, State, Label&gt; =\n    storeFactory.create&lt;Intent, Action, Msg, State, Label&gt;(\n        name = \"CounterStore\",\n        initialState = State(),\n        bootstrapper = coroutineBootstrapper { // Or reaktiveBootstrapper\n            // ...\n        },\n        executorFactory = coroutineExecutorFactory { // Or reaktiveExecutorFactory\n            // ...\n        },\n        reducer = { msg -&gt;\n            // ...\n        }\n    )\n\nprivate sealed interface Action {\n    // ...\n}\n\nprivate sealed interface Msg {\n    // ...\n}\n</code></pre>"},{"location":"time_travel/","title":"Time Travel","text":"<p>Time travel is a power debugging tool. It allows you to record all events and states from all active <code>Stores</code>. When events are recorded you can explore them, replay and debug. The core functionality is multiplatform and is implemented for all supported targets. However, some features are available only on specific platforms.</p> <p>\u26a0\ufe0f Time travel is a debugging tool and may affect performance, ideally it should not be used in production.</p> <p>There are three main steps to enable and use time travelling:</p> <ol> <li>Provide a time-travel-aware variant of the <code>StoreFactory</code> to all <code>Store</code> factories</li> <li>Run a time travel server on your app</li> <li>Use one of the provided clients to connect to the server and control the tool</li> </ol>"},{"location":"time_travel/#providing-a-storefactory-for-time-travelling","title":"Providing a StoreFactory for time travelling","text":"<p>The TimeTravelStoreFactory is used to create an implementation of <code>Store</code> that is able to record and replay events. In debug builds, this variant of the <code>StoreFactory</code> can be passed via DI to all <code>Store</code> factories instead of the <code>DefaultStoreFactory</code>.</p> <p>The functionality described in this section is available on all supported targets.</p> <p>Suppose there is the following <code>Store</code> factory:</p> <pre><code>internal class CalculatorStoreFactory(private val storeFactory: StoreFactory) {\n\n    fun create(): CalculatorStore =\n        object : CalculatorStore, Store&lt;Intent, State, Nothing&gt; by storeFactory.create(\n            name = \"CounterStore\",\n            // ...\n        ) {\n        }\n\n    // Omitted code\n}\n</code></pre> <p>It accepts a <code>StoreFactory</code> and uses it to create an implementation of the <code>CalculatorStore</code>. You can now pass any <code>StoreFactory</code> here. So if you want to enable time travelling, just pass an instance of the <code>TimeTravelStoreFactory</code>:</p> <pre><code>val storeFactory = TimeTravelStoreFactory()\n\nCalculatorStoreFactory(storeFactory).create()\n</code></pre> <p>You can also combine it with the <code>LoggingStoreFactory</code> in the following way:</p> <pre><code>val storeFactory = LoggingStoreFactory(TimeTravelStoreFactory())\n\nCalculatorStoreFactory(storeFactory).create()\n</code></pre> <p>Usually there should be a global instance of the <code>StoreFactory</code> somewhere in the main app, passed down to all the dependencies.</p>"},{"location":"time_travel/#running-the-time-travel-server","title":"Running the time travel server","text":"<p>Each app with time travelling enabled has a global instance of the TimeTravelController. Each <code>Store</code> automatically connects to the controller. The controller accepts various commands from outside, records events from the registered <code>Stores</code>, substitutes their states and re-triggers events for debugging purposes.</p> <p>In order to allow remote control, the app should run a time travel server. The server binds the <code>TimeTravelController</code> with the outside world. The way how the server is implemented is platform specific. Currently, the following targets are supported:</p> <ul> <li>JVM-based targets: <code>android</code> and <code>jvm</code></li> <li>Darwin/Apple targets: <code>ios</code>, <code>tvos</code>, <code>watchos</code> and <code>macos</code></li> <li>JavaScript (<code>js</code>), the Chrome browser only</li> </ul> <p>There should be no technical limitations to implement the server for other platforms. Contributions are welcome!</p> <p>All server implementations except the one for JavaScript are TCP-based. The default port is <code>6379</code> unless explicitly changed during the initialisation.</p> <p>\u26a0\ufe0f The communication protocol is open but is considered internal. There are no compatibility guarantees between different versions.</p>"},{"location":"time_travel/#running-the-time-travel-server-on-an-android-app","title":"Running the time travel server on an Android app","text":"<p>First import the time travel dependency in the application module. Replace <code>&lt;version&gt;</code> with the latest release version.</p> <pre><code>implementation(\"com.arkivanov.mvikotlin:mvikotlin-timetravel:&lt;version&gt;\")\n</code></pre> <p>In <code>Application#onCreate</code>, start the TimeTravelServer during <code>onCreate()</code>.</p> <pre><code>class App : Application() {\n    private val timeTravelServer = TimeTravelServer()\n\n    override fun onCreate() {\n        super.onCreate()\n        timeTravelServer.start()\n    }\n}\n</code></pre> <p>\u26a0\ufe0f Since the <code>TimeTravelServer</code> does use the internet on the device for communicating with the development machine, even if the app does not use the internet you will need to declare the <code>android.permission.INTERNET</code> permission.</p>"},{"location":"time_travel/#running-the-time-travel-server-on-a-jvm-app","title":"Running the time travel server on a JVM app","text":"<p>First import the time travel dependency in the application module. Replace <code>&lt;version&gt;</code> with the latest release version.</p> <pre><code>implementation(\"com.arkivanov.mvikotlin:mvikotlin-timetravel:&lt;version&gt;\")\n</code></pre> <p>In the <code>main</code> function of the application, create an instance of the TimeTravelServer and provide the <code>runOnMainThread</code> argument. This can be done with <code>SwingUtilities.invokeLater {}</code> or with coroutines/Reaktive if that is being used.</p> <pre><code>fun main() {\n    TimeTravelServer(runOnMainThread = { SwingUtilities.invokeLater(it) })\n        .start()\n}\n</code></pre>"},{"location":"time_travel/#running-the-time-travel-server-on-a-darwinapple-app","title":"Running the time travel server on a Darwin/Apple app","text":"<p>To set up the <code>TimeTravelServer</code> on a Darwin/Apple device, the <code>mvikotlin-timetravel</code> dependency must be exported into the shared module in <code>build.gradle.kts</code>. Also, the <code>mvikotlin-timetravel</code> module must be added as <code>api</code> dependency, adding as <code>implementation</code> is not enough. This can be done in the <code>commonMain</code> source set, or just only in a Darwin source sets.</p> <pre><code>kotlin {\n    ios {\n        binaries {\n            framework {\n                export(\"com.arkivanov.mvikotlin:mvikotlin-timetravel:&lt;version&gt;\")\n            }\n        }\n    }\n\n    sourceSets {\n        named(\"commonMain\") {\n            dependencies {\n                api(\"com.arkivanov.mvikotlin:mvikotlin-timetravel:&lt;version&gt;\")\n            }\n        }\n    }\n}\n</code></pre> <p>Then in your app, create and <code>start</code> an instance of the TimeTravelServer.</p> <pre><code>@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    private let s = TimeTravelServer()\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {\n        // Override point for customization after application launch.\n        s.start()\n\n        return true\n    }\n\n}\n</code></pre>"},{"location":"time_travel/#running-the-time-travel-server-for-the-chrome-browser-javascript","title":"Running the time travel server for the Chrome browser (JavaScript)","text":"<p>First import the time travel dependency in the application module. Replace <code>&lt;version&gt;</code> with the latest release version.</p> <pre><code>implementation(\"com.arkivanov.mvikotlin:mvikotlin-timetravel:&lt;version&gt;\")\n</code></pre> <p>In the <code>main</code> function of the application, start the TimeTravelServer.</p> <pre><code>fun main() {\n    TimeTravelServer().start()\n\n    // The reset of the code\n}\n</code></pre>"},{"location":"time_travel/#using-time-travel-clients","title":"Using time travel clients","text":"<p>The time travel client communicates to the server, and provides UI to control the feature and displays the data. At the moment, there are three variants of the client provided.</p> <ol> <li>The IntelliJ IDEA plugin - currently for Android applications only</li> <li>The standalone Java application - for Android, JVM and Darwin/Apple applications</li> <li>The Chrome extension - for JavaScript web applications</li> </ol>"},{"location":"time_travel/#using-the-intellij-idea-plugin","title":"Using the IntelliJ IDEA plugin","text":"<p>The IntelliJ IDEA plugin can be used directly from the IDE. By default it uses <code>adb</code> to connect to Android apps. However, you can switch to a TCP connection in the settings, so it could also connect to JVM and Darwin/Apple apps.</p>"},{"location":"time_travel/#how-to-install","title":"How to install","text":"<p>You can find the plugin in the IntelliJ IDEA Marketplace. It can be installed directly from IntelliJ IDEA or Android Studio. Please navigate to Settings -&gt; Plugins -&gt; Marketplace and type \"MVIKotlin\" in the search field.</p>"},{"location":"time_travel/#how-to-use","title":"How to use","text":"<p>The client connects to the <code>TimeTravelServer</code> running on an application via TCP. The default port is <code>6379</code>.</p> <p>To connect to an Android application running the <code>TimeTravelServer</code>, the easiest way is to simply open the settings and check the \"Connect via ADB\" checkbox. Then just click on the \"Connect\" button, the client will prompt you with the <code>adb</code> executable path and then the connection should be established. The client uses ADB to forward the TCP port.</p> <p>To connect to a non-Android application (or to an Android application without using the ADB) - open the settings, uncheck the \"Connect via ADB\" checkbox and type the host address of the device. For applications running locally (e.g. a JVM or a macOS application, an iOS application running on a simulator, etc.) the host address is usually <code>localhost</code>. For a remote device, the host address should be specified explicitly. Please refer to the device's settings to find out its TCP address. In any case, the server's port should be connectable (e.g. permissions are granted, the port is allow-listed, etc.).</p>"},{"location":"time_travel/#demo-video","title":"Demo video","text":"<p>Check out the video demonstrating the time travel IDEA plugin:</p> <p></p>"},{"location":"time_travel/#using-the-standalone-client-application-on-desktop","title":"Using the standalone client application on desktop","text":"<p>The desktop client app provides similar functionality to the IntelliJ IDEA plugin. But it can also connect to JVM and Darwin/Apple applications.</p> <p>\u26a0\ufe0f This client can not be used for Web (JavaScript) applications.</p> <p></p>"},{"location":"time_travel/#how-to-install_1","title":"How to install","text":"<p>You can download distributions for Linux and Windows from the Releases page on GitHub. For macOS you will need to build and run it from sources. Please run the following command (the minimum JDK version 11 is required):</p> <pre><code>./gradlew :mvikotlin-timetravel-client:app-desktop:run\n</code></pre>"},{"location":"time_travel/#how-to-use_1","title":"How to use","text":"<p>The usage is the same as for the IntelliJ IDEA plugin.</p>"},{"location":"time_travel/#building-a-distributable-version","title":"Building a distributable version","text":"<p>The time travel client for desktop is implemented using Compose for Desktop. So it is possible to assemble a distributable version. Please read the corresponding documentation page.</p>"},{"location":"time_travel/#demo-video_1","title":"Demo video","text":"<p>Check out the video demonstrating how you can debug an iOS app using the time travel client app:</p> <p></p>"},{"location":"time_travel/#using-the-chrome-browser-extension-experimental","title":"Using the Chrome browser extension (experimental)","text":"<p>The Chrome browser extension provides similar functionality to other time travel clients, but is specially designed for Web applications.</p> <p>\u26a0\ufe0f The time travel Chrome extension is currently experimental. Eventually it will be either promoted to stable or removed.</p>"},{"location":"time_travel/#how-to-install_2","title":"How to install","text":"<p>You can install the extension from the Chrome Web Store.</p>"},{"location":"time_travel/#how-to-use_2","title":"How to use","text":"<p>The extension adds a DevTools panel, which looks and works similar to other time travel clients. Make sure you have started the <code>TimeTravelServer</code> in your Web application. When the web page is loaded, right-click on it and select the \"Inspect\" menu item. Navigate to the \"MVIKotlin\" panel and click the \"Connect\" button. The extension will inject a special script into the web page, which proxies messages between the <code>TimeTravelServer</code> and the extension.</p>"},{"location":"time_travel/#demo-video_2","title":"Demo video","text":"<p>Check out the video demonstrating the time travel Chrome extension.</p> <p></p>"},{"location":"time_travel/#recording-the-events","title":"Recording the events","text":"<p>Once a time travel client is connected to an application, it can start recording events. Press the \"Start recording\" button to start the recording. All recording events will appear in the list on the left-hand side. To stop the recording, press the \"Stop recording\" button.</p>"},{"location":"time_travel/#inspecting-the-events","title":"Inspecting the events","text":"<p>When the recording is finished, the application enters the inspection state. In this state all <code>Stores</code> are disconnected from their inputs and outputs. All events are accumulated and postponed later, when the inspection is finished.</p> <p>Every recorded event can be inspected. Select an event in the list, the details will appear in the area on the right-hand side. The exact representation of the event details depends on the time travel server implementation and varies across platforms.</p> <p>The time travel server for Android and JVM uses reflection to precisely parse object properties.</p> <p>The time travel server for Darwin/Apple targets just uses the <code>toString</code> function. It is advised to define states, intents, actions and messages as <code>data class</code>.</p> <p>The time travel server for JavaScript uses the <code>JSON.stringify</code> function. Same as for Darwin/Apple, it is advised to use <code>data classes</code>.</p>"},{"location":"time_travel/#time-travelling","title":"Time travelling","text":"<p>During the inspection state, <code>Store</code> states can be rolled back and forward. The following buttons can be used:</p> <ul> <li>\"Move to start\" - moves to the very first recorded state</li> <li>\"Step backward\" - moves to the previous recorded state</li> <li>\"Step forward\" - moves to the next recorded state</li> <li>\"Move to end\" - moves to the latest recorded state</li> </ul> <p>The UI always displays the currently selected state.</p>"},{"location":"time_travel/#debugging-recorded-events","title":"Debugging recorded events","text":"<p>In the inspection state, each recorded event can be triggered again. A typical use case is to record an incorrect behaviour of an app, then put breakpoints in the code and trigger a recorded event. To trigger an event, select it in the list and click the \"Debug the selected event\" button.</p> <p>If the triggered event is an <code>Intent</code> or an <code>Action</code>, then a new debug instance of the <code>Executor</code> of the corresponding <code>Store</code> is created for each such event. The debug instance of the <code>Executor</code> has the same <code>State</code> as it was at the time of the recording. All <code>Messages</code> dispatched during the debug session are passed through the <code>Reducer</code> and the <code>State</code> of the debug instance of the <code>Executor</code> is updated accordingly. Any <code>Label</code> published during the event debug session is ignored.</p> <p>If the triggered event is a <code>Message</code>, then the <code>Reducer</code> is just called with the <code>Message</code> and the corresponding <code>State</code>. The result of the <code>Reducer</code> is ignored in this case.</p>"},{"location":"time_travel/#exporting-and-importing-events","title":"Exporting and importing events","text":"<p>This feature is currently only supported for JVM and Android applications. In order this feature to work, all related classes (<code>Intents</code>, <code>Actions</code>, <code>Messages</code>, <code>States</code> and <code>Labels</code>) must implement the Serializable interface. The <code>mvikotlin</code> module provides the handy JvmSerializable interface, which can be used in the common code.</p> <p>To export the recorded events, press on the \"Export events\" button. Select a folder and enter a file name in the file saving dialog and save the file. All the events will be serialized into the file.</p> <p>To import previously exported events, press the \"Import events\" button and select a file. All the events will be deserialized and applied to the corresponding <code>Stores</code>.</p> <p>\u26a0\ufe0f When importing the events, the application code should be the same as it was at the time of exporting. The classes being deserialized should match the serialized ones. Otherwise, the behaviour is undefined.</p>"},{"location":"time_travel/#demo-video_3","title":"Demo video","text":"<p>Check out the video demonstrating how you can export/import the time travel data using the IDEA plugin.</p> <p></p>"},{"location":"time_travel/#finishing-the-inspection","title":"Finishing the inspection","text":"<p>To finish the inspection, press the \"Cancel\" button. All pending <code>Intents</code> and <code>Labels</code> that were queued during the inspection are processed automatically.</p>"},{"location":"view/","title":"View","text":"<p>It is not necessary to follow any particular guide when implementing <code>Views</code>, however you may find useful what is provided by MVIKotlin.</p> <p>In MVIKotlin there are two basic interfaces related to <code>View</code>: - ViewRenderer - consumes and renders <code>Models</code> - ViewEvents - produces <code>Events</code></p> <p>There is also the MviView interface which is just a combination of both <code>ViewRenderer</code> and <code>ViewEvents</code> interfaces. Again you normally don't need to implement the <code>MviView</code> interface directly. Instead you can extend the BaseMviView class.</p> <p>\u26a0\ufe0f If you are using Jetpack Compose then most likely you don't need <code>MviView</code> or any of its super types. You can observe the <code>Store</code> directly in <code>@Composable</code> functions, just expose the state (or the mapped UI model) via <code>Observable</code> or <code>Flow</code>.</p>"},{"location":"view/#implementing-a-view","title":"Implementing a View","text":"<p>Let's implement a <code>View</code> for the <code>CalculatorStore</code> created here. As always we should first define an interface:</p> <pre><code>interface CalculatorView : MviView&lt;Model, Event&gt; {\n\n    data class Model(\n        val value: String\n    )\n\n    sealed class Event {\n        object IncrementClicked: Event()\n        object DecrementClicked: Event()\n    }\n}\n</code></pre> <p>The <code>CalculatorView</code> is public so it can be implemented natively by every platform, e.g. Android and iOS. Our <code>CalculatorView</code> consumes a simple <code>Model</code> with just a value text and produces two <code>Events</code> (<code>IncrementClicked</code> and <code>DecrementClicked</code>).</p> <p>You may notice that <code>Model</code> and <code>Events</code> look very similar to <code>CalculatorStore.State</code> and <code>CalculatorStore.Intent</code>. In this particular case our <code>CalculatorView</code> could directly render <code>State</code> and produce <code>Intents</code>. But in general it is a good practice to have separate <code>Models</code> and <code>Events</code>. This removes coupling between <code>Views</code> and <code>Stores</code>.</p> <p>An Android implementation can look like this:</p> <pre><code>class CalculatorViewImpl(root: View) : BaseMviView&lt;Model, Event&gt;(), CalculatorView {\n\n    private val textView = root.requireViewById&lt;TextView&gt;(R.id.text)\n\n    init {\n        root.requireViewById&lt;View&gt;(R.id.button_increment).setOnClickListener {\n            dispatch(Event.IncrementClicked)\n        }\n        root.requireViewById&lt;View&gt;(R.id.button_decrement).setOnClickListener {\n            dispatch(Event.DecrementClicked)\n        }\n    }\n\n    override fun render(model: Model) {\n        super.render(model)\n\n        textView.text = model.value\n    }\n}\n</code></pre> <p>Here is a possible iOS implementation using SwiftUI:</p> <pre><code>class CalculatorViewProxy: BaseMviView&lt;CalculatorViewModel, CalculatorViewEvent&gt;, CalculatorView, ObservableObject {\n\n    @Published var model: CalculatorViewModel?\n\n    override func render(model: CalculatorViewModel) {\n        self.model = model\n    }\n}\n\nstruct CalculatorView: View {\n    @ObservedObject var proxy = CalculatorViewProxy()\n\n    var body: some View {\n        VStack {\n            Text(proxy.model?.value ?? \"\")\n\n            Button(action: { self.proxy.dispatch(event: CalculatorViewEvent.IncrementClicked()) }) {\n                Text(\"Increment\")\n            }\n\n            Button(action: { self.proxy.dispatch(event: CalculatorViewEvent.DecrementClicked()) }) {\n                Text(\"Decrement\")\n            }\n        }\n    }\n}\n\n</code></pre> <p>For a more complex UI please refer to the samples.</p>"},{"location":"view/#efficient-view-updates","title":"Efficient view updates","text":"<p>Sometimes it may be inefficient to update the entire <code>View</code> each time a new <code>Model</code> is received. For example, if a <code>View</code> contains a text and a list, it may be useful not to update the list if only the text is changed. MVIKotlin provides the diff tool for this.</p> <p>Suppose we have a <code>UserInfoView</code> that displays a user's name and a list of friends:</p> <pre><code>interface UserInfoView : MviView&lt;Model, Nothing&gt; {\n\n    data class Model(\n        val name: String,\n        val friendNames: List&lt;String&gt;\n    )\n}\n</code></pre> <p>We can use <code>diff</code> in the following way:</p> <pre><code>class UserInfoViewImpl : BaseMviView&lt;Model, Nothing&gt;(), UserInfoView {\n\n    private val nameText: TextView = TODO()\n    private val friendsList: ListView = TODO()\n\n    override val renderer: ViewRenderer&lt;Model&gt;? = diff {\n        diff(get = Model::name, set = nameText::setText)\n        diff(get = Model::friendNames, compare = { a, b -&gt; a === b }, set = friendsList::setItems)\n    }\n}\n</code></pre> <p>Every <code>diff</code> statement accepts a <code>getter</code> that extracts a value from the <code>Model</code>, a <code>setter</code> that sets the value to the view and an optional <code>comparator</code> of values.</p>"}]}